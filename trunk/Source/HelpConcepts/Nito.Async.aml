<?xml version="1.0" encoding="utf-8"?>
<topic id="8059f511-e59f-4aae-b282-942fcb857d61" revisionNumber="1">
    <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
        <introduction>
            <para>Nito Programs is pleased to provide the Nito.Async library.</para>
        </introduction>
        <section address="SectionInto">
            <title>Introduction to Nito.Async</title>
            <content>
                <para>
                    Nito.Async provides the <codeEntityReference>T:Nito.Async.ActionThread</codeEntityReference> type, which is a thread containing an event-based message loop. It also provides a synchronization context, which means it may own classes developed using the event-based asynchronous pattern (e.g., <codeEntityReference>T:System.ComponentModel.BackgroundWorker</codeEntityReference>).
                </para>
                <para>
                    There is also a non-platform-specific <codeEntityReference>T:Nito.Async.Timer</codeEntityReference>, which is a reliable timer type that may be used in cross-platform components (e.g., it works equally well with WPF and Windows Forms projects).
                </para>
                <para>
                    <codeEntityReference>T:Nito.Async.GenericSynchronizingObject</codeEntityReference> may be used as a bridge, allowing older asynchronous components based on the <codeEntityReference>T:System.ComponentModel.ISynchronizeInvoke</codeEntityReference> model (exposing a <codeInline>SynchronizingObject</codeInline> property) to work seamlessly with the modern <codeEntityReference>T:System.Threading.SynchronizationContext</codeEntityReference> approach.
                </para>
                <para>
                    The <codeEntityReference>T:Nito.Async.ActionDispatcher</codeEntityReference> provides a main loop and synchronization context for any thread that doesn't already have one. This can be used to convert threads to be event-based. One example of usage is to convert a Console application's main thread to be event-driven, so that it may own event-based asynchronous pattern objects.
                </para>
                <para>
                    Nito.Async also provides a collection of synchronizing methods (<codeEntityReference>T:Nito.Async.Sync</codeEntityReference>) to help synchronize with asynchronous components based on <codeEntityReference>T:System.IAsyncResult</codeEntityReference> or similar free-threaded patterns.
                </para>
                <para>
                    These methods may be used in conjunction with <codeEntityReference>T:Nito.Async.AsyncResultEventArgs`1</codeEntityReference> and <codeEntityReference>T:Nito.Async.CallbackContext</codeEntityReference> to develop components using the
                    <externalLink>
                        <linkText>event-based asynchronous pattern.</linkText>
                        <linkUri>http://msdn.microsoft.com/en-us/library/wewwczdw.aspx</linkUri>
                    </externalLink>
                </para>
                <para>
                    For advanced users, Nito.Async also provides a <codeEntityReference>T:System.Threading.SynchronizationContext</codeEntityReference> register that keeps track of properties of different derived synchronization context types. Since the register already is aware of <codeEntityReference>T:System.Windows.Forms.WindowsFormsSynchronizationContext</codeEntityReference>, <codeEntityReference>T:System.Windows.Threading.DispatcherSynchronizationContext</codeEntityReference>, <codeEntityReference>T:Nito.Async.ActionDispatcherSynchronizationContext</codeEntityReference>, and <codeInline>AspNetSynchronizationContext</codeInline>, modifying the synchronization context register should be very rare.
                </para>
            </content>
        </section>
        <relatedTopics>
        </relatedTopics>
    </developerConceptualDocument>
</topic>