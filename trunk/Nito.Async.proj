<Project ToolsVersion="3.5" DefaultTargets="BuildRelease" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\ExtensionPack\MSBuild.ExtensionPack.tasks" />

  <!-- Recommended command-line: msbuild /nologo /p:Version=2.0 /fl1 /flp1:v=diag -->
  
  <!-- We do not do automatic SCC checkins or "get latest"; this allows rebuilding previous releases. -->

  <ItemGroup>
    <!--
      The DLLs to build; these assumptions are made:
        There is a Properties/AssemblyInfo.cs file underneath these directories that contains version information.
        The outputs are a triple: DLL, XML, and PDB, placed into the same subdirectory.
    -->
    <Projects Include="Source\**\*.csproj"/>

    <!-- The certificate to use for strong-name signing (a missing file is not an error; the signing is just skipped instead) -->
    <StrongNameCertificate Include="C:\Work\Nito\_\Code Signing\Certificates\Microsoft Strong Name\Microsoft Strong Name Private Key.snk"/>

    <!-- The certificate to use for authenticode signing (a missing file is not an error; the signing is just skipped instead) -->
    <AuthenticodeCertificate Include="C:\Work\Nito\_\Code Signing\Certificates\GlobalSign ObjectSign Code Signing Certificate\MSCV-GlobalSign.cer"/>

    <!-- All sources for the library projects -->
    <Sources Include="Source\**\*.cs"/>
  </ItemGroup>

  <!-- Defines the steps necessary to build a release -->
  <Target Name="BuildRelease"
          DependsOnTargets="UpdateVersions;BuildLibraries;BuildHelp"
          >
  </Target>

  <!-- Ensures $(Version) is as expected, and defines $(MajorVersion), $(MinorVersion), and $(FullVersion) -->
  <Target Name="CalculateVersion">
    <!-- Ensure $(Version) is defined -->
    <Error Condition="'$(Version)' == ''" Text="Version must be defined, e.g., /p:Version=3.0" />
    
    <!-- Split out $(Version) into two parts -->
    <MSBuild.ExtensionPack.Framework.MSBuildHelper TaskAction="StringToItemCol"
                                                   ItemString="$(Version)"
                                                   Separator="."
                                                   >
      <Output TaskParameter="OutputItems" ItemName="VersionDetail"/>
      <Output TaskParameter="ItemCount" PropertyName="VersionDetailCount"/>
    </MSBuild.ExtensionPack.Framework.MSBuildHelper>
    <Error Condition="'$(VersionDetailCount)' != '2'" Text="Version must consist of two numbers, e.g., /p:Version=3.0" />
    
    <!-- Set $(MajorVersion) -->
    <MSBuild.ExtensionPack.Framework.MSBuildHelper TaskAction="GetItem"
                                                   InputItems1="@(VersionDetail)"
                                                   Position="0">
      <Output TaskParameter="OutputItems" ItemName="MajorVersion"/>
    </MSBuild.ExtensionPack.Framework.MSBuildHelper>
    
    <!-- Set $(MinorVersion) -->
    <MSBuild.ExtensionPack.Framework.MSBuildHelper TaskAction="GetItem"
                                                   InputItems1="@(VersionDetail)"
                                                   Position="1">
      <Output TaskParameter="OutputItems" ItemName="MinorVersion"/>
    </MSBuild.ExtensionPack.Framework.MSBuildHelper>
    
    <!-- Set $(ShortVersion) -->
    <PropertyGroup>
      <FullVersion>$(Version).0.0</FullVersion>
    </PropertyGroup>
  </Target>
  
  <!-- Updates the version declarations in the source -->
  <Target Name="UpdateVersions" DependsOnTargets="CalculateVersion">
    <Message Text="Updating to Version: $(Version)" />

    <!-- Find the AssemblyInfo.cs files to update -->
    <ItemGroup>
      <AssemblyInfos Include="@(Projects->'%(RelativeDir)Properties\AssemblyInfo.cs')" />
    </ItemGroup>

    <!-- Remove AssemblyFileVersion statements -->
    <MSBuild.ExtensionPack.FileSystem.File TaskAction="FilterByContent"
                                           RegexPattern="\[assembly: AssemblyFileVersion\(%22.*%22\)\]"
                                           Files="@(AssemblyInfos)"
                                           >
      <Output TaskParameter="IncludedFiles" ItemName="AssemblyInfosWithAssemblyFileVersion"/>
    </MSBuild.ExtensionPack.FileSystem.File>
    <MSBuild.ExtensionPack.FileSystem.File Condition="'@(AssemblyInfosWithAssemblyFileVersion)' != ''"
                                           TaskAction="Replace"
                                           RegexPattern="\[assembly: AssemblyFileVersion\(%22.*%22\)\]"
                                           Replacement=""
                                           Files="@(AssemblyInfosWithAssemblyFileVersion)"
                                           />
    
    <!-- Ignore any AssemblyInfo files that already have the correct version (this avoids unnecessary builds due to updating files with the same data) -->
    <MSBuild.ExtensionPack.FileSystem.File TaskAction="FilterByContent"
                                           RegexPattern="\[assembly: AssemblyVersion\(%22$(FullVersion)%22\)\]"
                                           Files="@(AssemblyInfos)"
                                           >
      <Output TaskParameter="ExcludedFiles" ItemName="AssemblyInfosWithWrongVersion"/>
    </MSBuild.ExtensionPack.FileSystem.File>
    
    <!-- Do the actual version update -->
    <MSBuild.ExtensionPack.FileSystem.File Condition="'@(AssemblyInfosWithWrongVersion)' != ''"
                                           TaskAction="Replace"
                                           RegexPattern="\[assembly: AssemblyVersion\(%22.*%22\)\]"
                                           Replacement="[assembly: AssemblyVersion(%22$(FullVersion)%22)]"
                                           Files="@(AssemblyInfosWithWrongVersion)"
                                           />
  </Target>

  <!-- This task should be run *after* UpdateVersions, if UpdateVersions is required
    1) Build all .csproj files under Source (with strong-name signing if possible)
    2) Authenticode-signs the dlls if possible
    3) Corrects the xml documentation files so that referring to method overload pages is possible
    4) Copies output to appropriate directories
  -->
  <ItemGroup>
    <BuildLibrariesInputs Include="@(Projects)"/>
    <BuildLibrariesInputs Include="@(Sources)"/>
    <BuildLibrariesInputs Include="Source\Nito.FxCop"/>
  </ItemGroup>
  <ItemGroup>
    <BuildLibrariesOutputs Include="@(Projects->'release\%(Filename).dll')"/>
    <BuildLibrariesOutputs Include="@(Projects->'release\%(Filename).pdb')"/>
    <BuildLibrariesOutputs Include="@(Projects->'staging\xml\%(Filename).xml')"/>
  </ItemGroup>
  <Target Name="BuildLibraries"
          Inputs="@(BuildLibrariesInputs)"
          Outputs="@(BuildLibrariesOutputs)"
          >
    <!-- Build the actual DLLs, strong-name signing if possible -->
    <PropertyGroup Condition="Exists(@(StrongNameCertificate))">
      <BuildProperties>Configuration=Release;SignAssembly=true;AssemblyOriginatorKeyFile=@(StrongNameCertificate)</BuildProperties>
    </PropertyGroup>
    <PropertyGroup Condition="!Exists(@(StrongNameCertificate))">
      <BuildProperties>Configuration=Release;SignAssembly=false</BuildProperties>
    </PropertyGroup>
    <MSBuild Projects="@(Projects)" Targets="Rebuild" Properties="$(BuildProperties)" StopOnFirstFailure="true">
      <Output TaskParameter="TargetOutputs" ItemName="BuildOutputs"/>
    </MSBuild>
    
    <!-- Run FxCop -->
    <MSBuild.ExtensionPack.CodeQuality.FxCop TaskAction="Analyse"
                                             Project="Source\Nito.FxCop"
                                             OutputFile="FxCopLog.txt"
                                             >
      <Output TaskParameter="AnalysisFailed" PropertyName="FxCopResult"/>
      <Output TaskParameter="OutputText" PropertyName="FxCopErrorMessage"/>
    </MSBuild.ExtensionPack.CodeQuality.FxCop>
    <Error Condition="'$(FxCopResult)' == 'true'" Text="FxCop failed: $(OutputText)"/>
    
    <!-- Correct XML documentation using XSL -->
    <PropertyGroup>
      <CorrectXMLDocumentation>
        <![CDATA[<?xml version='1.0'?>
        <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>
          <xsl:output method="xml" indent="yes"/>

          <!-- Copy all documentation as-is except for what matches other rules -->
          <xsl:template match="@* | node()">
            <xsl:copy>
              <xsl:apply-templates select="@* | node()"/>
            </xsl:copy>
          </xsl:template>

          <!-- Convert "cref" references that start with "O:" to starting with "Overload:". -->
          <xsl:template match="@cref[starts-with(., 'O:')]">
            <xsl:attribute name="cref">
              <xsl:value-of select="concat('Overload:', substring-after(., 'O:'))"/>
            </xsl:attribute>
          </xsl:template>
        </xsl:stylesheet>]]>
      </CorrectXMLDocumentation>
    </PropertyGroup>
    <ItemGroup>
      <XmlOutputs Include="@(BuildOutputs->'%(RelativeDir)%(Filename).xml')"/>
    </ItemGroup>
    <MakeDir Directories="staging\xml"/>
    <MSBuild.ExtensionPack.Xml.XmlTask TaskAction="TransForm"
                                       XmlFile="%(XmlOutputs.Identity)"
                                       OutputFile="@(XmlOutputs->'staging\xml\%(Filename).xml')"
                                       XslTransform="$(CorrectXMLDocumentation)"
                                       />

    <!-- Authenticode-sign the DLLs if possible -->
    <SignFile Condition="Exists(@(AuthenticodeCertificate))"
              CertificateThumbprint="47217be8be4e7ae0aba1cce53a704222c216eead"
              SigningTarget="%(BuildOutputs.Identity)"
              TimestampUrl="http://timestamp.globalsign.com/scripts/timstamp.dll"
              />
    
    <!-- Copy DLL files and PDB files to binary output folders -->
    <Copy SourceFiles="@(BuildOutputs)" DestinationFolder="release" />
    <Copy SourceFiles="@(BuildOutputs->'%(RootDir)%(Directory)%(Filename).pdb')" DestinationFolder="release" />
  </Target>

  <!-- Build the help file -->
  <ItemGroup>
    <HelpConceptFiles Include="Source\**\*.aml"/>
  </ItemGroup>
  <ItemGroup>
    <BuildHelpInputs Include="Help\$(Version)\Nito.Async.shfbproj"/>
    <BuildHelpInputs Include="@(BuildLibrariesOutputs)"/>
    <BuildHelpInputs Include="@(HelpConceptFiles)"/>
  </ItemGroup>
  <ItemGroup>
    <BuildHelpOutputs Include="release\Nito.Async.chm"/>
    <BuildHelpOutputs Include="@(Projects->'release\%(Filename).xml')"/>
  </ItemGroup>
  <Target Name="BuildHelp"
          Inputs="@(BuildHelpInputs)"
          Outputs="@(BuildHelpOutputs)"
          >
    <!-- Ensure help folder exists for this release -->
    <PropertyGroup>
      <HelpFolder>Help\$(Version)\</HelpFolder>
    </PropertyGroup>
    <Error Condition="!Exists($(HelpFolder))" Text="Help folder does not exist for version $(Version)"/>
    
    <!-- Copy DLL and xml files to help folder -->
    <Copy SourceFiles="@(Projects->'release\%(Filename).dll')" DestinationFolder="$(HelpFolder)" SkipUnchangedFiles="true"/>
    <Copy SourceFiles="@(Projects->'staging\xml\%(Filename).xml')" DestinationFolder="$(HelpFolder)" SkipUnchangedFiles="true"/>
    
    <!-- Copy all help concept files to help folder (flattening directory hierarchy) -->
    <Copy SourceFiles="@(HelpConceptFiles)" DestinationFolder="$(HelpFolder)" SkipUnchangedFiles="true"/>
    
    <!-- Build help file -->
    <MSBuild Projects="$(HelpFolder)Nito.Async.shfbproj" Properties="Configuration=Release"/>
    
    <!-- Copy help file and updated xml files to release folder -->
    <Copy SourceFiles="$(HelpFolder)Help\Nito.Async.chm;@(Projects->'$(HelpFolder)Help\%(Filename).xml')" DestinationFolder="release"/>
  </Target>
  
<!--

TODO:
. Publisher Policies - Build the publisher policies - automagically? Or just error if they don't include the current version and minor # is not 0
. Package into zip (?)
. Source-index PDBs
. Run unit tests on compiled code
. CheckCopyrights
. Consider StyleCop

-->

</Project>